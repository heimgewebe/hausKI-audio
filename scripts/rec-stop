#!/usr/bin/env python3
"""Stop the active pw-record session launched via rec-start."""
from __future__ import annotations

import argparse
import os
import signal
import time
from pathlib import Path

STATE_DIR = Path.home() / ".cache" / "hauski-audio"
PID_FILE = STATE_DIR / "recording.pid"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Stop the current recorder if running.")
    parser.add_argument(
        "--timeout",
        type=float,
        default=5.0,
        help="Seconds to wait for recorder to exit after sending SIGINT (default: 5).",
    )
    parser.add_argument(
        "--signal",
        choices=["INT", "TERM", "KILL"],
        default="INT",
        help="Primary signal to send (default: INT).",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="If recorder ignores the primary signal, escalate to SIGKILL at the end of timeout.",
    )
    return parser.parse_args()


def read_pid() -> int:
    if not PID_FILE.exists():
        raise SystemExit("No recorder PID state found. Is rec-start running?")
    try:
        pid = int(PID_FILE.read_text().strip())
    except ValueError:
        PID_FILE.unlink(missing_ok=True)
        raise SystemExit("PID file contained invalid data; cleared stale state.")
    return pid


def process_alive(pid: int) -> bool:
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    return True


def send_signal(pid: int, signame: str) -> None:
    sig = getattr(signal, f"SIG{signame}")
    try:
        os.kill(pid, sig)
    except ProcessLookupError:
        pass
    except PermissionError as exc:
        raise SystemExit(f"Not permitted to signal process {pid}: {exc}") from exc


def wait_exit(pid: int, timeout: float) -> bool:
    deadline = time.time() + timeout
    while time.time() < deadline:
        if not process_alive(pid):
            return True
        time.sleep(0.2)
    return not process_alive(pid)


def main() -> None:
    args = parse_args()
    pid = read_pid()
    if not process_alive(pid):
        PID_FILE.unlink(missing_ok=True)
        print("Recorder already stopped; cleared stale PID file.")
        return

    send_signal(pid, args.signal)
    if wait_exit(pid, args.timeout):
        PID_FILE.unlink(missing_ok=True)
        print(f"Recorder {pid} stopped.")
        return

    if args.force:
        print(f"Recorder {pid} ignored SIG{args.signal}; sending SIGKILL.")
        send_signal(pid, "KILL")
        wait_exit(pid, 1.0)
        PID_FILE.unlink(missing_ok=True)
        print(f"Recorder {pid} killed.")
    else:
        raise SystemExit(
            f"Recorder {pid} did not exit within {args.timeout}s. Re-run with --force to kill hard."
        )


if __name__ == "__main__":
    main()
