#!/usr/bin/env python3
"""Stop the active pw-record session launched via rec-start."""
from __future__ import annotations

import argparse
import json
import os
import signal
import time
from pathlib import Path

STATE_DIR = Path.home() / ".cache" / "hauski-audio"
PID_FILE = STATE_DIR / "recording.pid"


class RecorderStateError(RuntimeError):
    pass


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Stop the current recorder if running.")
    parser.add_argument(
        "--timeout",
        type=float,
        default=5.0,
        help="Seconds to wait for recorder to exit after sending SIGINT (default: 5).",
    )
    parser.add_argument(
        "--signal",
        choices=["INT", "TERM", "KILL"],
        default="INT",
        help="Primary signal to send (default: INT).",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="If recorder ignores the primary signal, escalate to SIGKILL at the end of timeout.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Output the signal plan without touching the process.",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Emit dry-run details as JSON (only with --dry-run).",
    )
    return parser.parse_args()


def read_pid() -> int:
    if not PID_FILE.exists():
        raise RecorderStateError("No recorder PID state found. Is rec-start running?")
    try:
        pid = int(PID_FILE.read_text().strip())
    except ValueError:
        PID_FILE.unlink(missing_ok=True)
        raise RecorderStateError("PID file contained invalid data; cleared stale state.")
    return pid


def process_alive(pid: int) -> bool:
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    return True


def send_signal(pid: int, signame: str) -> None:
    sig = getattr(signal, f"SIG{signame}")
    try:
        os.kill(pid, sig)
    except ProcessLookupError:
        pass
    except PermissionError as exc:
        raise RecorderStateError(f"Not permitted to signal process {pid}: {exc}")


def wait_exit(pid: int, timeout: float) -> bool:
    deadline = time.time() + timeout
    while time.time() < deadline:
        if not process_alive(pid):
            return True
        time.sleep(0.2)
    return not process_alive(pid)


def main() -> None:
    args = parse_args()
    try:
        pid = read_pid()
    except RecorderStateError as exc:
        print(str(exc))
        raise SystemExit(1) from exc

    if not process_alive(pid):
        PID_FILE.unlink(missing_ok=True)
        print("Recorder already stopped; cleared stale PID file.")
        return

    if args.dry_run:
        payload = {
            "pid": pid,
            "signal": args.signal,
            "timeout": args.timeout,
            "force": args.force,
        }
        if args.json:
            print(json.dumps(payload, indent=2))
        else:
            print(f"Plan: send SIG{args.signal} to {pid}, wait {args.timeout}s, force={args.force}")
        return

    try:
        send_signal(pid, args.signal)
        if wait_exit(pid, args.timeout):
            PID_FILE.unlink(missing_ok=True)
            print(f"Recorder {pid} stopped.")
            return

        if args.force:
            print(f"Recorder {pid} ignored SIG{args.signal}; sending SIGKILL.")
            send_signal(pid, "KILL")
            wait_exit(pid, 1.0)
            PID_FILE.unlink(missing_ok=True)
            print(f"Recorder {pid} killed.")
        else:
            raise RecorderStateError(
                f"Recorder {pid} did not exit within {args.timeout}s. Re-run with --force to kill hard."
            )
    except RecorderStateError as exc:
        print(str(exc))
        raise SystemExit(1) from exc


if __name__ == "__main__":
    main()
