#!/usr/bin/env python3
"""Toggle Mopidy audio output between PulseAudio and ALSA."""
from __future__ import annotations

import argparse
import subprocess
import sys
import re
from pathlib import Path

DEFAULT_CONFIG = Path.home() / ".config" / "mopidy" / "mopidy.conf"
DEFAULT_PULSE = "pulsesink"
DEFAULT_ALSA_FALLBACK = "alsasink device=hw:MOTU_M2,0"
DEFAULT_CARD_HINT = "M2"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Switch Mopidy's audio sink between PulseAudio and ALSA modes.",
    )
    parser.add_argument(
        "mode",
        nargs="?",
        choices=["pulse", "alsa", "show"],
        default="alsa",
        help="Target mode or show current configuration (default: alsa).",
    )
    parser.add_argument(
        "--config",
        default=str(DEFAULT_CONFIG),
        help="Path to mopidy.conf (default: %(default)s).",
    )
    parser.add_argument(
        "--alsa-output",
        default=None,
        help="ALSA output string to write when mode=alsa (auto-detect MOTU when unset).",
    )
    parser.add_argument(
        "--pulse-output",
        default=DEFAULT_PULSE,
        help="Pulse output string to write when mode=pulse.",
    )
    parser.add_argument(
        "--restart",
        dest="restart",
        action="store_true",
        help="Restart Mopidy via systemctl --user after writing audio mode.",
    )
    parser.add_argument(
        "--no-restart",
        dest="restart",
        action="store_false",
        help="Skip Mopidy restart (default: restart)",
    )
    parser.set_defaults(restart=True)
    parser.add_argument(
        "--control-pipewire",
        dest="control_pipewire",
        action="store_true",
        help="Toggle PipeWire/Pulse services when switching modes (default: enabled).",
    )
    parser.add_argument(
        "--no-control-pipewire",
        dest="control_pipewire",
        action="store_false",
        help="Do not manage PipeWire services.",
    )
    parser.set_defaults(control_pipewire=True)
    parser.add_argument(
        "--card-hint",
        default=DEFAULT_CARD_HINT,
        help="Substring to detect MOTU card via aplay -l (default: %(default)s).",
    )
    parser.add_argument(
        "--aplay-bin",
        default="aplay",
        help="Path to aplay executable for card detection (default: %(default)s).",
    )
    return parser.parse_args()


def load_lines(path: Path) -> list[str]:
    try:
        return path.read_text().splitlines(keepends=True)
    except FileNotFoundError:
        print(f"Config file not found: {path}", file=sys.stderr)
        sys.exit(2)


def find_section(lines: list[str], section: str) -> tuple[int | None, int | None]:
    section_header = f"[{section.lower()}]"
    start = None
    for idx, raw in enumerate(lines):
        if raw.strip().lower() == section_header:
            start = idx
            break
    if start is None:
        return None, None
    end = len(lines)
    for idx in range(start + 1, len(lines)):
        if lines[idx].lstrip().startswith("["):
            end = idx
            break
    return start, end


def extract_output(lines: list[str], start: int, end: int) -> tuple[int | None, str | None]:
    for idx in range(start + 1, end):
        stripped = lines[idx].split("#", 1)[0].split(";", 1)[0].strip()
        if stripped.lower().startswith("output"):
            parts = stripped.split("=", 1)
            if len(parts) == 2:
                return idx, parts[1].strip()
            return idx, None
    return None, None


def write_mode(path: Path, mode: str, pulse_output: str, alsa_output: str) -> str:
    lines = load_lines(path)
    start, end = find_section(lines, "audio")
    if start is None or end is None:
        print("No [audio] section found in config; unable to continue.", file=sys.stderr)
        sys.exit(2)

    output_idx, current_value = extract_output(lines, start, end)
    desired = pulse_output if mode == "pulse" else alsa_output

    if output_idx is None:
        insert_at = end
        newline = lines[start][-1:] if lines[start].endswith("\n") else "\n"
        lines.insert(insert_at, f"output = {desired}{newline}")
    else:
        newline = "\n" if lines[output_idx].endswith("\n") else ""
        lines[output_idx] = f"output = {desired}{newline}"

    path.write_text("".join(lines))
    return current_value or "(unset)"


def show_mode(path: Path) -> None:
    lines = load_lines(path)
    start, end = find_section(lines, "audio")
    if start is None or end is None:
        print("[audio] section missing")
        return
    _, current_value = extract_output(lines, start, end)
    print(current_value or "(output unset)")


def restart_mopidy() -> None:
    result = subprocess.run(
        ["systemctl", "--user", "restart", "mopidy"],
        check=False,
    )
    if result.returncode != 0:
        print("systemctl did not exit cleanly.", file=sys.stderr)
        sys.exit(result.returncode)


def manage_service(action: str, service: str) -> None:
    subprocess.run(
        ["systemctl", "--user", action, service],
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def detect_motu_device(aplay_bin: str, card_hint: str) -> str | None:
    try:
        result = subprocess.run(
            [aplay_bin, "-l"],
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
        )
    except FileNotFoundError:
        return None

    if result.returncode != 0:
        return None

    pattern = re.compile(r"card\s+(\d+):.*" + re.escape(card_hint), re.IGNORECASE)
    for line in result.stdout.splitlines():
        match = pattern.search(line)
        if match:
            card_idx = match.group(1)
            return f"hw:{card_idx},0"
    return None


def control_pipewire(mode: str, enabled: bool) -> None:
    if not enabled:
        return

    if mode == "alsa":
        manage_service("stop", "pipewire-pulse")
        manage_service("stop", "pipewire")
    elif mode == "pulse":
        manage_service("start", "pipewire")
        manage_service("start", "pipewire-pulse")


def main() -> None:
    args = parse_args()
    config_path = Path(args.config).expanduser()

    if args.mode == "show":
        show_mode(config_path)
        return

    control_pipewire(args.mode, args.control_pipewire)

    alsa_output = args.alsa_output
    detected_device = None
    if args.mode == "alsa" and alsa_output is None:
        detected_device = detect_motu_device(args.aplay_bin, args.card_hint)
        if detected_device is None:
            alsa_output = DEFAULT_ALSA_FALLBACK
        else:
            alsa_output = f"alsasink device={detected_device}"

    if args.mode == "pulse":
        desired_output = args.pulse_output
    else:
        desired_output = alsa_output or DEFAULT_ALSA_FALLBACK

    previous = write_mode(
        config_path,
        args.mode,
        pulse_output=args.pulse_output,
        alsa_output=desired_output,
    )

    suffix = ""
    if detected_device:
        suffix = f" (card {detected_device})"
    print(f"Audio output changed from '{previous}' to '{args.mode}'{suffix}.")

    if args.restart:
        restart_mopidy()


if __name__ == "__main__":
    main()
